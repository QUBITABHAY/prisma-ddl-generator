import pkg from '@prisma/internals';
const { getDMMF } = pkg;
import fs from 'fs';

const DIALECTS = {
  mysql: {
    quote: (s) => `\`${s}\``,
    varchar: (n = 191) => `VARCHAR(${n})`,
    datetime: () => `DATETIME(3)`,
    integer: () => `INTEGER`,
    float: () => `DOUBLE`,
    json: () => `JSON`,
    boolean: () => `BOOLEAN`,
    autoIncrementSuffix: 'AUTO_INCREMENT',
    tableOptions: () => 'DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci',
    defaultNow: 'CURRENT_TIMESTAMP(3)'
  },
  postgres: {
    quote: (s) => `"${s.replace(/"/g, '""')}"`,
    varchar: (n = 191) => `VARCHAR(${n})`,
    datetime: () => `TIMESTAMP(3)`,
    integer: () => `INTEGER`,
    float: () => `DOUBLE PRECISION`,
    json: () => `JSONB`,
    boolean: () => `BOOLEAN`,
    autoIncrementSuffix: 'GENERATED BY DEFAULT AS IDENTITY',
    tableOptions: () => '',
    defaultNow: 'CURRENT_TIMESTAMP(3)'
  },
  sqlite: {
    quote: (s) => `"${s}"`,
    varchar: (n = 191) => `VARCHAR(${n})`,
    datetime: () => `DATETIME`,
    integer: () => `INTEGER`,
    float: () => `REAL`,
    json: () => `JSON`,
    boolean: () => `BOOLEAN`,
    autoIncrementSuffix: 'AUTOINCREMENT',
    tableOptions: () => '',
    defaultNow: 'CURRENT_TIMESTAMP'
  }
};

function typeFor(field, dialect) {
  const d = DIALECTS[dialect];
  const { type } = field;
  const isRequired = (field.isRequired ?? (!field.isNullable));
  const required = isRequired ? 'NOT NULL' : 'NULL';

  switch (type) {
    case 'Int': return `${d.integer()} ${required}`;
    case 'String': return `${d.varchar()} ${required}`;
    case 'DateTime': return `${d.datetime()} ${required}`;
    case 'Boolean': return `${d.boolean()} ${required}`;
    case 'Float': return `${d.float()} ${required}`;
    case 'Json': return `${d.json()} ${required}`;
    default: return `TEXT ${required}`;
  }
}

export function genSQL(dmmf, dialect = 'mysql') {
  const d = DIALECTS[dialect];
  if (!d) throw new Error(`Unsupported dialect: ${dialect}`);

  const modelsByName = Object.fromEntries(dmmf.datamodel.models.map(m => [m.name, m]));
  // collect enums for dialects that need explicit type creation (e.g., Postgres)
  const enumTypes = dmmf.datamodel.enums || [];
  const foreignKeys = [];
  let sql = '';

  // Emit enum types for Postgres
  if (dialect === 'postgres' && enumTypes.length) {
    for (const en of enumTypes) {
      const values = en.values.map(v => `'${v.name}'`).join(',');
      sql += `CREATE TYPE ${d.quote(en.name)} AS ENUM (${values});\n`;
    }
    sql += `\n`;
  }

  for (const model of dmmf.datamodel.models) {
    sql += `-- CreateTable\n`;
    sql += `CREATE TABLE ${d.quote(model.name)} (\n`;

    const cols = [];
    const uniques = [];
    const primaryKeys = [];

    for (const field of model.fields) {
      if (field.kind === 'object') continue;

      const colName = d.quote(field.name);
      let typeSql = typeFor(field, dialect);
      if (field.kind === 'enum') {
        if (dialect === 'postgres') {
          typeSql = `${d.quote(field.type)} ${(/NOT NULL/.test(typeSql) ? 'NOT NULL' : 'NULL')}`;
        } else if (dialect === 'mysql') {
          const en = enumTypes.find(e => e.name === field.type);
          if (en) {
            const values = en.values.map(v => `'${v.name}'`).join(',');
            typeSql = `ENUM(${values}) ${(/NOT NULL/.test(typeSql) ? 'NOT NULL' : 'NULL')}`;
          }
        }
      }

      if (field.isId && field.default?.name === 'autoincrement') {
        if (dialect === 'mysql') {
          typeSql = typeSql.replace(/INTEGER\s*(NOT NULL|NULL)/, (m, p1) => `INTEGER ${p1} ${d.autoIncrementSuffix}`);
        } else if (dialect === 'postgres') {
          typeSql = typeSql.replace(/INTEGER\s*(NOT NULL|NULL)/, (m, p1) => `INTEGER ${p1} ${d.autoIncrementSuffix}`);
        } else if (dialect === 'sqlite') {
        }
      }

      // defaults
      if (field.default?.name === 'now') {
        if (!/CURRENT_TIMESTAMP/.test(typeSql)) typeSql += ` DEFAULT ${d.defaultNow}`;
      } else if (field.hasDefault && field.default != null && typeof field.default !== 'object') {
        if (typeof field.default === 'number' || typeof field.default === 'boolean') {
          typeSql += ` DEFAULT ${field.default}`;
        } else if (typeof field.default === 'string') {
          typeSql += ` DEFAULT '${field.default.replace(/'/g, "''")}'`;
        }
      }

      cols.push(`  ${colName} ${typeSql}`);

      if (field.isUnique && !field.isId) uniques.push({ model: model.name, field: field.name });
      if (field.isId) primaryKeys.push(field.name);

      if (/Id$/.test(field.name) && field.type === 'Int') {
        const prefix = field.name.slice(0, -2);
        const target = prefix.charAt(0).toUpperCase() + prefix.slice(1);
        if (modelsByName[target]) {
          const onDelete = /(Registration|Review)/i.test(model.name) ? 'CASCADE' : 'RESTRICT';
          foreignKeys.push({ table: model.name, column: field.name, referencedTable: target, referencedColumn: 'id', constraintName: `${model.name}_${field.name}_fkey`, onDelete, onUpdate: 'CASCADE' });
        }
      }
    }

    if (dialect === 'sqlite' && primaryKeys.length === 1) {
      const pk = primaryKeys[0];
      for (let i = 0; i < cols.length; i++) {
        if (cols[i].includes(d.quote(pk))) {
          cols[i] = cols[i].replace(/INTEGER\s*(NOT NULL|NULL)/, (m, p1) => `INTEGER ${p1} PRIMARY KEY ${d.autoIncrementSuffix}`);
          break;
        }
      }
    }

    sql += cols.join(',\n') + ',\n\n';

    for (const u of uniques) {
      if (dialect === 'postgres') {
        sql += `  CONSTRAINT ${d.quote(`${u.model}_${u.field}_key`)} UNIQUE (${d.quote(u.field)}),\n`;
      } else {
        sql += `  UNIQUE INDEX ${d.quote(`${u.model}_${u.field}_key`)}(${d.quote(u.field)}),\n`;
      }
    }

    if (primaryKeys.length > 0) {
      const pkCols = primaryKeys.map(c => d.quote(c)).join(', ');
      sql += `  PRIMARY KEY (${pkCols})\n`;
    } else {
      sql = sql.replace(/,\n\n$/, '\n\n');
    }

    const tableOpts = d.tableOptions();
    sql += `)${tableOpts ? ' ' + tableOpts : ''};\n\n`;
  }

  for (const fk of foreignKeys) {
    sql += `-- AddForeignKey\n`;
    sql += `ALTER TABLE ${d.quote(fk.table)} ADD CONSTRAINT ${d.quote(fk.constraintName)} FOREIGN KEY (${d.quote(fk.column)}) REFERENCES ${d.quote(fk.referencedTable)}(${d.quote(fk.referencedColumn)}) ON DELETE ${fk.onDelete} ON UPDATE ${fk.onUpdate};\n\n`;
  }

  return sql;
}

export async function prismaToSQL({ schemaPath = './schema.prisma', dialect = 'mysql' } = {}) {
  if (dialect.toLowerCase() === 'mariadb') dialect = 'mysql';
  const schema = fs.readFileSync(schemaPath, 'utf8');
  const dmmf = await getDMMF({ datamodel: schema });

  const sql = genSQL(dmmf, dialect);
  return sql;
}

async function main() {
  let dialect = process.argv[2] || process.env.SQL_DIALECT || 'mysql';
  if (dialect.toLowerCase() === 'mariadb') dialect = 'mysql';
  const schema = fs.readFileSync('./schema.prisma', 'utf8');
  const dmmf = await getDMMF({ datamodel: schema });

  const sql = genSQL(dmmf, dialect);
  const outName = `output.${process.argv[2] || dialect}.sql`;
  fs.writeFileSync(outName, sql);
  console.log(`Wrote ${outName}`);
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
